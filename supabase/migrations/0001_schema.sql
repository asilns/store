-- Schema and RLS for multi-tenant orders dashboard
create extension if not exists pgcrypto;
create table if not exists public.stores (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  is_suspended boolean not null default false,
  created_at timestamptz not null default now()
);

create table if not exists public.users (
  id uuid primary key,
  email text not null unique,
  created_at timestamptz not null default now()
);

create type public.store_role as enum ('owner','admin','manager','staff','viewer');

create table if not exists public.user_store_map (
  user_id uuid references public.users(id) on delete cascade,
  store_id uuid references public.stores(id) on delete cascade,
  role public.store_role not null,
  primary key (user_id, store_id)
);

create table if not exists public.products (
  id uuid primary key default gen_random_uuid(),
  store_id uuid not null references public.stores(id) on delete cascade,
  name text not null,
  sku text not null,
  price_cents integer not null,
  is_active boolean not null default true,
  created_at timestamptz not null default now()
);

create unique index if not exists products_store_sku_unique on public.products(store_id, sku);

create table if not exists public.orders (
  id uuid primary key default gen_random_uuid(),
  store_id uuid not null references public.stores(id) on delete cascade,
  order_number bigint generated by default as identity,
  customer_name text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- auto-update updated_at
create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists trg_orders_set_updated_at on public.orders;
create trigger trg_orders_set_updated_at
before update on public.orders
for each row execute function public.set_updated_at();

create table if not exists public.order_items (
  id uuid primary key default gen_random_uuid(),
  order_id uuid not null references public.orders(id) on delete cascade,
  product_id uuid references public.products(id),
  quantity integer not null check (quantity > 0),
  price_cents integer not null,
  unit_cost_cents integer not null,
  commission_bps integer not null default 0,
  commission_cents integer not null default 0,
  profit_cents integer not null default 0
);

create table if not exists public.subscriptions (
  id uuid primary key default gen_random_uuid(),
  store_id uuid not null references public.stores(id) on delete cascade,
  plan text not null,
  starts_at date not null,
  ends_at date not null,
  grace_days integer not null default 0,
  status text not null default 'active',
  updated_at timestamptz not null default now()
);

-- Persist commission and profit on insert/update of order_items
create or replace function public.compute_commission_profit()
returns trigger as $$
begin
  new.commission_cents := floor(new.price_cents * new.commission_bps / 10000.0)::int;
  new.profit_cents := (new.price_cents - new.unit_cost_cents - new.commission_cents)::int;
  return new;
end;
$$ language plpgsql;

drop trigger if exists trg_order_items_compute on public.order_items;
create trigger trg_order_items_compute
before insert or update of price_cents, unit_cost_cents, commission_bps on public.order_items
for each row execute function public.compute_commission_profit();

-- Export views
create or replace view public.orders_export_view as
select o.*, (select count(*) from public.order_items oi where oi.order_id = o.id) as items_count
from public.orders o;

create or replace view public.products_export_view as
select * from public.products;

-- RLS policies
alter table public.products enable row level security;
alter table public.orders enable row level security;
alter table public.order_items enable row level security;
alter table public.stores enable row level security;
alter table public.user_store_map enable row level security;

-- Helper function to check membership
create or replace function public.is_member_of_store(uid uuid, sid uuid)
returns boolean language sql stable as $$
  select exists(
    select 1 from public.user_store_map m where m.user_id = uid and m.store_id = sid
  );
$$;

create or replace function public.can_write_store(uid uuid, sid uuid)
returns boolean language sql stable as $$
  select exists(
    select 1 from public.user_store_map m
    where m.user_id = uid and m.store_id = sid and m.role <> 'viewer'
  );
$$;

-- Policies: select limited to member stores
create policy if not exists products_select on public.products for select using (
  public.is_member_of_store(auth.uid(), store_id)
);
create policy if not exists products_modify on public.products for all using (
  public.can_write_store(auth.uid(), store_id)
) with check (
  public.can_write_store(auth.uid(), store_id)
);

create policy if not exists orders_select on public.orders for select using (
  public.is_member_of_store(auth.uid(), store_id)
);
create policy if not exists orders_modify on public.orders for all using (
  public.can_write_store(auth.uid(), store_id)
) with check (
  public.can_write_store(auth.uid(), store_id)
);

create policy if not exists order_items_select on public.order_items for select using (
  exists (
    select 1 from public.orders o where o.id = order_id and public.is_member_of_store(auth.uid(), o.store_id)
  )
);
create policy if not exists order_items_modify on public.order_items for all using (
  exists (
    select 1 from public.orders o where o.id = order_id and public.can_write_store(auth.uid(), o.store_id)
  )
) with check (
  exists (
    select 1 from public.orders o where o.id = order_id and public.can_write_store(auth.uid(), o.store_id)
  )
);

-- Stores visibility to members only
create policy if not exists stores_select on public.stores for select using (
  public.is_member_of_store(auth.uid(), id)
);

-- user_store_map visibility to the user themselves
create policy if not exists user_store_map_select on public.user_store_map for select using (
  user_id = auth.uid()
);

-- Admin RPC for cron to refresh subscription statuses
create or replace function public.refresh_subscriptions()
returns json language plpgsql security definer as $$
declare
  updated_count int;
begin
  update public.subscriptions s
  set status = case
    when current_date <= s.ends_at then 'active'
    when current_date <= s.ends_at + s.grace_days then 'past_due'
    else 'expired'
  end,
  updated_at = now();
  get diagnostics updated_count = row_count;
  return json_build_object('updated', updated_count);
end;
$$;


